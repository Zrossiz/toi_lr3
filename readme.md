# Лабораторная работа №3

## Раздел 5. Языки программирования и основы трансляции

**Темы:**

* Формальные языки и грамматики
* Основы трансляции программ

---

## 1. Постановка задачи

Целью лабораторной работы является закрепление теоретических знаний и получение практических навыков по следующим направлениям:

* разработка формальных грамматик выражений;
* реализация процедур синтаксического анализа методом рекурсивного спуска;
* построение внутреннего представления выражения в виде дерева;
* разработка интерпретатора выражений на языке C++ с использованием только стандартной библиотеки.

В рамках работы требуется разработать программу, которая:

* распознаёт корректные арифметико-логические выражения;
* обнаруживает и локализует синтаксические ошибки;
* строит дерево выражения;
* выводит выражение в виде обратной польской записи;
* вычисляет значение выражения при заданных значениях переменных.

---

## 2. Описание грамматики выражений

Для решения задачи была разработана LL(1)-грамматика арифметико-логических выражений с поддержкой:

* целых и вещественных чисел;
* идентификаторов (переменных);
* арифметических операций `+ - * /`;
* операций сравнения `== != < > <= >=`;
* логических операций `&& ||`;
* круглых скобок;
* разделителей (пробелов).

### 2.1 Грамматика в расширенной БНФ

```
<expression>   ::= <or_expr>
<or_expr>      ::= <and_expr> { "||" <and_expr> }
<and_expr>     ::= <cmp_expr> { "&&" <cmp_expr> }
<cmp_expr>     ::= <add_expr> [ ("==" | "!=" | "<" | ">" | "<=" | ">=") <add_expr> ]
<add_expr>     ::= <mul_expr> { ("+" | "-") <mul_expr> }
<mul_expr>     ::= <unary> { ("*" | "/") <unary> }
<unary>        ::= ["+" | "-"] <primary>
<primary>      ::= NUMBER | IDENT | "(" <expression> ")"
```

Грамматика не содержит левой рекурсии и пригодна для синтаксического анализа методом рекурсивного спуска.

---

## 3. Примеры выражений

### 3.1 Синтаксически корректные выражения

* `a + b * 3`
* `(x - 2) * y`
* `a > 5 && b < 10`
* `(a + b) >= c || d != 0`
* `x / 2 + y * 4`

### 3.2 Выражения с ошибками

* `a + * b` — отсутствует операнд
* `(a + b` — отсутствует закрывающая скобка
* `a && || b` — неверная последовательность операций
* `5 / (3 - 3)` — семантическая ошибка (деление на ноль)

При обнаружении ошибок программа прекращает разбор и выводит сообщение с указанием причины ошибки и позиции символа.

---

## 4. Алгоритм синтаксического анализа

Синтаксический анализ реализован методом рекурсивного спуска. Для каждого нетерминала грамматики разработана отдельная функция.

Общий алгоритм:

1. Лексический анализ входной строки и получение токенов.
2. Последовательный вызов функций разбора в соответствии с грамматикой.
3. При успешном разборе — построение дерева выражения.
4. При обнаружении ошибки — прекращение разбора и вывод сообщения об ошибке.

Каждая функция разбора:

* проверяет корректность текущего токена;
* вызывает функции более низкого приоритета;
* обеспечивает соблюдение приоритетов операций.

---

## 5. Внутреннее представление выражения

Для представления выражения используется бинарное дерево.

* Листовые вершины — числа или переменные.
* Внутренние вершины — операции.

Структура узла дерева:

* строка с именем операции или переменной;
* числовое значение (для констант);
* указатели на левое и правое поддерево.

В случае ошибки в записи выражения построенное дерево не используется.

---

## 6. Обратная польская запись

Для вывода выражения в обратной польской записи используется рекурсивный обход дерева (postorder).

Пример:

Исходное выражение:

```
a + b * 3
```

Обратная польская запись:

```
a b 3 * +
```

---

## 7. Интерпретация выражений

Вычисление значения выражения выполняется рекурсивным обходом дерева.

Алгоритм вычисления:

* если узел — число, возвращается его значение;
* если узел — переменная, значение берётся из таблицы идентификаторов;
* если узел — операция, рекурсивно вычисляются подвыражения и применяется операция.

Реализована обработка следующих ошибок:

* использование неинициализированных переменных;
* деление на ноль;
* неизвестные операции.

---

## 8. Работа с переменными

Для хранения значений переменных используется таблица идентификаторов на основе `std::map`.

Пользователь вводит значения всех переменных перед выполнением вычислений, что исключает повторный ввод значений и снижает вероятность ошибок.

Программа поддерживает повторное вычисление выражения с другими значениями переменных без повторного синтаксического анализа.

---

## 9. Тестирование

В ходе тестирования были проверены:

* все правила грамматики;
* корректные и некорректные выражения;
* обработка семантических ошибок;
* корректность построения дерева и обратной польской записи.

Результаты тестирования подтвердили корректность работы программы.

---

## 10. Заключение

В ходе выполнения лабораторной работы:

* разработана расширенная грамматика выражений;
* реализован синтаксический анализ методом рекурсивного спуска;
* построено дерево выражения;
* реализован интерпретатор выражений;
* обеспечена диагностика синтаксических и семантических ошибок.

Поставленные задачи выполнены в полном объёме, требования лабораторной работы соблюдены.



```mermaid
flowchart TD
  E["Expression"] --> AE["and_expr"]
  AE --> CMP["comparison"]
  CMP --> ADD0["add"]
  ADD0 --> MUL0["mul"]

  %% (a + b)
  MUL0 --> U1["unary"]
  U1 --> P1["primary"]
  P1 --> LPAR1["("]
  P1 --> EX1["expression"]
  P1 --> RPAR1[")"]

  EX1 --> ADD1["add"]
  ADD1 --> MUL1["mul"]
  MUL1 --> U1A["unary"]
  U1A --> P1A["primary"]
  P1A --> AID["IDENT : a"]

  ADD1 --> PLUS["+"]

  ADD1 --> MUL2["mul"]
  MUL2 --> U1B["unary"]
  U1B --> P1B["primary"]
  P1B --> BID["IDENT : b"]

  %% *
  MUL0 --> STAR["*"]

  %% (c - 2)
  MUL0 --> U2["unary"]
  U2 --> P2["primary"]
  P2 --> LPAR2["("]
  P2 --> EX2["expression"]
  P2 --> RPAR2[")"]

  EX2 --> ADD2["add"]
  ADD2 --> MUL3["mul"]
  MUL3 --> U2A["unary"]
  U2A --> P2A["primary"]
  P2A --> CID["IDENT : c"]

  ADD2 --> MINUS["-"]

  ADD2 --> MUL4["mul"]
  MUL4 --> U2B["unary"]
  U2B --> P2B["primary"]
  P2B --> NUM["NUMBER : 2"]

  %% Styles
  classDef nonterm fill:#cfead1,stroke:#2e7d32,stroke-width:1px,color:#000;
  classDef op fill:#ffd1dc,stroke:#ad1457,stroke-width:1px,color:#000;
  classDef term fill:#ffe0b2,stroke:#ef6c00,stroke-width:1px,color:#000;

  class E,AE,CMP,ADD0,MUL0,EX1,ADD1,MUL1,MUL2,U1,U1A,U1B,P1,P1A,P1B,EX2,ADD2,MUL3,MUL4,U2,U2A,U2B,P2,P2A,P2B nonterm;
  class PLUS,MINUS,STAR op;
  class AID,BID,CID,NUM,LPAR1,RPAR1,LPAR2,RPAR2 term;
```
